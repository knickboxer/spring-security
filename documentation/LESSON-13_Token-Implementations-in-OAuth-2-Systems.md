# Spring Security
[TOC](./README.md)

## Lesson 13 - Token implementations in OAuth 2 systems

⭐ Timestamps ⭐
- 1:00 QA on implicit vs Authorization Code Grant type
- 16:00 What is an opaque token
- 20:00 Opaque Token Implementation & How Resource server valdiates Opaque Token
- 32:40 How to configure Different password encode for Client credentials(Different than User credentials)
- 40:22 How to configure Access Token expiry time
- 41:00 Validate the Access Token
- 51:00 Blackborading Access Token
- 55:00 How Resource server valdiates Opaque Token
- 01:04:00 Introduction of JWT

### Opaque Token
#### What is a opaque token

An opaque token is a token that doesn't have any kind of information in it. In that way it is like a password: a string
that authenticates a user, but with any details about it's usage or any other details.   
To gain details about the user and the scope of the the token, the receiving party has to get the details from somewhere
else like the authorzation server.

The default token generated by the system looks like a UUID but indeed is an MD5 hash over some data provided for
authorization.

### Token Validation

Token validation is the process of validating a token that has been presented to resource server.

#### Validation of opaque token

There are two options for Token validation. One is to ask the authorization service if the access token is valid. This
option is called **token introspection**.

The other option is called **token blackboarding** and it is to use a shared database for the access tokens. The
authorization service stores a token in the database and the resource server can also access the database and can verify
that the token is valid. One possible solution to this scenario is Redis as a high speed cache solution, that stores the
token. This can be implemented by using a JDBC Token Store shared between authorization and resource server.

There is also a third option, when authorization server and resource server are the same application. In this scenario
the same application shows up in two different roles.

#### Token validation with token introspection endpoint

The "oauth/check_token" endpoint is secured so you can't access this endpoint right way. You have to enable access to this
endpoint, otherwise any request is denied with 401.

You can set a web security expression to the `AuthorizationServerSecurityConfigurer.checkTokenAccess()` to enable that
endpoint.
```java
@Override
    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
        security.checkTokenAccess("isAuthenticated()"); // isAuthenticated()
    }
```

Following web security expressions can be used:
- _hasRole_, _hasAnyRole_
- _hasAuthority_, _hasAnyAuthority_
- _permitAll_, _denyAll_
- _isAnonymous_, _isRememberMe_, _isAuthenticated_, _isFullyAuthenticated_
- _principal_, _authentication_
- _hasPermission_

See [Web Security Expressions](https://www.baeldung.com/spring-security-expressions) for a description.

```java
    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
        security.passwordEncoder(passwordEncoder);
    }
```

After enableing access to the endpoint you can call the endpoint with the token to see if it is valid

```java
    http://127.0.0.1:8080/oauth/check_token?token=3ba1f54e-0425-4a18-ba15-86a10a4750c1
```

When the token is valid, you get a json object with information about the user that contains it's name, scopes, and expiry time.

```json
{
    "active": true,
    "exp": 1647103708,
    "user_name": "john",
    "authorities": [
        "read"
    ],
    "client_id": "client1",
    "scope": [
        "read"
    ]
}
```
If the token is not valid you may see the following message.
```json
{
"error": "invalid_token",
"error_description": "Token was not recognised"
}
```
If the token is expired you see a message like this one.
```json
{
  "error": "invalid_token",
  "error_description": "Token has expired"
}
```

### Implementing Resource and Authorization Server as one application

To do this you have to add a `ResourceServerConfiguration` and implement a controller,



**NOTE***

If you use a password encoder different from NoOpPasswordEncoder you have to encrypt the passwords
in the client configuration.

```java
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()
            .withClient("client1")
            .secret(
                    passwordEncoder.encode("secret1")
            )
        ...
    }
```

Therefore you have to configure the password encoder with the `AuthorizationServerConfigurerAdapter`

```java
    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
        security.passwordEncoder(passwordEncoder);
    }
```

### JWT type Token

JWT contains already a lot of information and ist can be proved to be valid without accessing another server.
The token itself contains information about the user, expiration and many other data supplied by so called claims.

These tokens are signed by the authorization server and can be proved valid when the resource server has a the key to
check the token signature. 

[TOC](./README.md)
